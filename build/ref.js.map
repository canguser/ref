{"version":3,"file":"ref.js","sources":["webpack://@palerock/ref/webpack/universalModuleDefinition","webpack://@palerock/ref/./src/main/index.js","webpack://@palerock/ref/./src/main/Ref.js","webpack://@palerock/ref/./src/utils.js","webpack://@palerock/ref/./src/main/Link.js","webpack://@palerock/ref/./src/main/InitialValue.js","webpack://@palerock/ref/webpack/bootstrap","webpack://@palerock/ref/webpack/runtime/define property getters","webpack://@palerock/ref/webpack/runtime/hasOwnProperty shorthand","webpack://@palerock/ref/webpack/runtime/make namespace object","webpack://@palerock/ref/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn ","import Ref from \"./Ref\";\nimport Link from \"./Link\";\nimport Utils from \"../utils\";\nimport InitialValue from \"./InitialValue\";\n\n/**\n * @param target {Object}\n * @param vars {Object|Array}\n * @param mapping {function}\n * @return {*}\n */\nexport const ref = function (target, vars, mapping) {\n    let varsList = Utils.getKeysOfConfiguration(vars);\n    const r = new Ref(vars);\n    const {proxy} = r;\n    for (const variable of varsList) {\n        proxy[variable] = link(params => {\n            mapping(params, target);\n        });\n    }\n    return proxy;\n};\n\n/**\n * @param targets {Array<Object>}\n * @param vars {Object|Array}\n * @param mapping {function}\n * @return {*}\n */\nexport const refs = function (targets = [], vars, mapping) {\n    let varsList = Utils.getKeysOfConfiguration(vars);\n    const r = new Ref(vars);\n    const {proxy} = r;\n    for (const variable of varsList) {\n        proxy[variable] = link(params => {\n            targets.forEach(target => {\n                mapping(params, target);\n            });\n        });\n    }\n    return proxy;\n};\n\nexport const initial = function (value) {\n    return new InitialValue(value);\n};\n\nexport const createRef = function (initialVars = {}, options) {\n    const linkRef = new Ref(initialVars, options);\n    return linkRef.proxy;\n};\n\nexport const link = function (...args) {\n    return new Link(...args);\n};\n\nexport {Ref, Link, InitialValue};","import Utils from \"../utils\";\nimport Link from \"./Link\";\n\nconst defaultOptions = {\n    isAsync: true\n};\n\nexport default class Ref {\n\n    constructor(initialVars = {}, options) {\n        let vars = initialVars;\n        if (initialVars instanceof Array) {\n            vars = {};\n            for (const name of initialVars) {\n                if (typeof name === 'string') {\n                    vars[name] = undefined;\n                }\n            }\n        }\n        if (!Utils.isConfigurableObject(vars)) {\n            vars = {};\n        }\n        this.vars = vars || {};\n        this.varsMapping = {};\n        this.options = {...defaultOptions, ...options};\n\n        this.proxy = Utils.getProxyChain(this.vars, {\n            get: (\n                {\n                    origin: [, name],\n                    info: {parentNames}\n                }\n            ) => {\n                const propertyChain = parentNames.concat(name);\n                this.declareVar(propertyChain[0]);\n            },\n            set: (\n                {\n                    origin: [, name, value],\n                    info: {parentNames}\n                }\n            ) => {\n                const propertyChain = parentNames.concat(name);\n                const propertyName = propertyChain[0];\n                const originValue = Utils.getProperty(this.vars, propertyChain);\n                if (value instanceof Link) {\n                    value.applyVar(propertyName);\n                    this._addMappedLink(propertyName, value);\n                    // apply related vars\n                    if (value.vars && value.vars.length > 0) {\n                        value.vars.forEach(\n                            variable => {\n                                this._addMappedLink(variable, value);\n                            }\n                        )\n                    }\n                    // console.log(value.initialValue, originValue)\n                    if (value.initialValue !== undefined && originValue === undefined) {\n                        // console.log(propertyChain, value.initialValue);\n                        Utils.setProperty(this.vars, propertyChain, value.initialValue);\n                    }\n                } else {\n                    Utils.setProperty(this.vars, propertyChain, value);\n                    // console.log('propertyChain', propertyChain);\n                    const links = this._getMappedLinks(propertyName);\n                    // console.log(propertyName);\n                    const actions = () => {\n                        if (links.length > 0) {\n                            links.forEach(link => {\n                                if (typeof link.action === 'function') {\n                                    link.action(this.proxy);\n                                }\n                            })\n                        }\n                    };\n                    if (this.isAsync) {\n                        Utils.delay(this, 'waitAssign', 0).then(() => actions());\n                    } else {\n                        actions();\n                    }\n                }\n            }\n        });\n    }\n\n    get isAsync() {\n        return !!this.options.isAsync;\n    }\n\n    declareVar(name, value) {\n        if (!(name in this.vars)) {\n            this.vars[name] = value;\n        }\n    }\n\n    infectAll(callback) {\n        this.infect(Object.keys(this.vars), callback);\n    }\n\n    infect(vars, callback) {\n        vars.forEach(\n            variable => {\n                this._addMappedLink(variable, new Link(\n                    callback\n                ))\n            }\n        )\n    }\n\n    _getMappedLinks(varName) {\n        return this.varsMapping[varName] || [];\n    }\n\n    _addMappedLink(varName, link) {\n        const links = this._getMappedLinks(varName);\n        if (!links.includes(link)) {\n            links.push(link);\n            this.varsMapping[varName] = links;\n            if (!(varName in this.vars)) {\n                this.vars[varName] = undefined;\n            }\n        }\n    }\n\n    static setDefaultOption(options) {\n        Object.assign(defaultOptions, options);\n    }\n\n}","export default class Utils {\n    /**\n     * Parse the property name to name array.\n     *  eg:\n     *      'a.b.c.d.e.t' => [a,b,c,d,e,t]\n     * @param keyChain\n     * @returns {*}\n     */\n    static parseKeyChain(keyChain) {\n        if (typeof keyChain === 'string') {\n            keyChain = keyChain.split('.');\n        }\n        return keyChain.filter(k => typeof k === 'string').map(k => k.replace(/ /g, ''));\n    }\n\n    /**\n     * Get the object property, it's support to using link property name like: a.b.c.d.e.f\n     * @param _self\n     * @param propertyName\n     * @returns {*}\n     */\n    static getProperty(_self, propertyName) {\n        if (_self == null) {\n            return undefined;\n        }\n        propertyName = this.parseKeyChain(propertyName);\n        if (propertyName.length === 1) {\n            return _self[propertyName[0]];\n        } else if (propertyName.length > 1) {\n            return this.getProperty(_self[propertyName[0]], propertyName.splice(1));\n        }\n        return undefined;\n    }\n\n    /**\n     * Create the proxy object for target object\n     * The proxy object will return the proxy for its children using the same set method.\n     * @param target\n     * @param set {function} - the method to hook all set method for the proxy.\n     * @param get\n     * @param keepNull {boolean=} - if false, proxy object will just return the empty object instance\n     * @param parentNames {Array=} - using to know the parent name for its children.\n     * @returns {*}\n     */\n    static getProxyChain(target, {set, get} = {}, keepNull = true, parentNames = []) {\n        if (target == null && !keepNull) {\n            target = {};\n        }\n        if (this.isBasicDataType(target)) {\n            return target;\n        }\n        return new Proxy(target, {\n            get: (t, name, receiver) => {\n                if (typeof name === 'string' && name.startsWith('$')) {\n                    return target[name.replace('$', '')];\n                }\n                get && (get instanceof Function) && get.call(t, {\n                    origin: [t, name, receiver],\n                    info: {parentNames}\n                });\n                return this.getProxyChain(t[name], {set, get}, keepNull, [...parentNames, name]);\n            },\n            set: (t, name, value, receiver) => {\n                set && (set instanceof Function) && set.call(t, {\n                    origin: [t, name, value, receiver],\n                    info: {parentNames}\n                });\n                return true;\n            }\n        });\n    }\n\n    static isBasicDataType(obj) {\n        return ['string', 'number', 'boolean', 'function'].includes(typeof obj) || obj instanceof Date || obj == null;\n    }\n\n    /**\n     * Set the object property, it's support to using link property name like: a.b.c.d.e.f\n     * @param _self\n     * @param propertyName {string|Array}\n     * @param value\n     * @returns {*}\n     */\n    static setProperty(_self, propertyName, value) {\n        propertyName = this.parseKeyChain(propertyName);\n        if (propertyName.length === 0) {\n            return true;\n        }\n        if (_self == null) {\n            return false;\n        }\n        if (propertyName.length === 1) {\n            _self[propertyName[0]] = value;\n            return true;\n        } else if (propertyName.length > 1) {\n            let thisKey = propertyName.splice(0, 1);\n            let canSet = this.setProperty(_self[thisKey[0]], propertyName, value);\n            if (!canSet) {\n                _self[thisKey[0]] = {};\n                return this.setProperty(_self[thisKey[0]], propertyName, value);\n            }\n        }\n        return true;\n    }\n\n    static isConfigurableObject(obj) {\n        return typeof obj === 'object' && !(obj instanceof Array) && !(obj instanceof Date) && Object.prototype.toString.call(obj) === '[object Object]'\n    }\n\n    static getKeysOfConfiguration(config) {\n        if (this.isConfigurableObject(config)) {\n            return Object.keys(config);\n        } else if (config instanceof Array) {\n            return config;\n        }\n        return [];\n    }\n\n    static test(describe, cb) {\n        try {\n            cb({\n                assert(condition, message = '', ...data) {\n                    if (!condition) {\n                        if (data.length > 0) {\n                            console.log('Assertion data:', data);\n                        }\n                        throw new Error(`Assertion failed: ${message}`)\n                    }\n                },\n                equals(except, actual, ...data) {\n                    const condition = except === actual;\n                    if (!condition) {\n                        if (data.length > 0) {\n                            console.log('Assertion data:', data);\n                        }\n                        throw new Error(`Assertion failed - except: ${except}, actually: ${actual}`)\n                    }\n                }\n            });\n            console.log(`Testing: ${describe} passed!`);\n        } catch (e) {\n            console.error(e.message);\n            console.error(`Testing: ${describe} failed...`)\n        }\n    }\n\n    static waitTodo(ms, params) {\n        return new Promise(resolve => {\n            setTimeout(() => {\n                resolve(params);\n            }, ms);\n        });\n    }\n\n    static delay(context, apiName, ms) {\n        const eqName = `_delay_${apiName}`;\n        clearTimeout(context[eqName]);\n        return new Promise(resolve => {\n            context[eqName] = setTimeout(() => {\n                resolve(true);\n            }, ms);\n        });\n    }\n}","export default class Link {\n\n    constructor(...args) {\n        this.extraVars = [];\n        if (typeof args[0] === 'object') {\n            const [vars, action, initialValue] = args;\n            if (vars instanceof Array) {\n                this.setVars(vars);\n                this.setAction(action);\n                this.setInitialValue(initialValue);\n            }\n        } else if (typeof args[0] === 'function') {\n            const [action, initialValue] = args;\n            this.setAction(action);\n            this.setInitialValue(initialValue);\n        }\n    }\n\n    setInitialValue(value) {\n        // console.log('initial',value);\n        if (this.initialValue === undefined) {\n            this.initialValue = value;\n        }\n    }\n\n    get vars() {\n        return [this.mainlyVar, ...this.extraVars];\n    }\n\n    setAction(action = () => undefined) {\n        if (!this.action && typeof action === 'function') {\n            this.action = action;\n        }\n    }\n\n    applyVar(variable) {\n        this.mainlyVar = variable;\n    }\n\n    setVars(vars = []) {\n        this.extraVars = vars;\n    }\n}","import Link from \"./Link\";\n\nexport default class InitialValue extends Link {\n\n    constructor(value) {\n        super();\n        this.initialValue = value;\n    }\n\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(0);\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;ACpKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACNA;AACA;AACA;AACA;;;A","sourceRoot":""}